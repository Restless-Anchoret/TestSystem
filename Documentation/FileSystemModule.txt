Структура папки со всеми файлами имеет следующий вид:

- file_system
	- problems
		- <Имя папки задачи>
			- tests
				- samples
					- 1
						input.txt
						answer.txt
					- 2
						input.txt
						answer.txt
					...
				- pretests
					...
				- tests_1
					...
				...
				- tests_8
					...
			- checker
				<Скомпилированные файлы чекера> // (Например, SimpleChecker.class, SimpleChecker$1.class и т. д.)
			- author_decisions
				- <Имя папки авторского решения>
					- bin
						<Скомпилированные файлы> // (Например, Task.class, Task$1.class и т. д.)
					- src
						<Файл решения> // (Например, Task.java)
				- <Имя папки авторского решения>
					...
				...
			statement.pdf
		- <Имя папки задачи>
			...
		...
	- submissions
		- <Имя папки посылки>
			- bin
				<Скомпилированные файлы> // (Например, Task.class, Task$1.class и т. д.)
			- src
				<Файл решения> // (Например, Task.java)
		- <Имя папки посылки>
			...
		...
	- competitions
		- <Имя папки соревнования>
			visible_results.xml
		- <Имя папки соревнования>
			...
		...
	- temp
		<Временные файлы> // (Например, 2356236325662.txt)
	- config
		java_problem.policy
		<Другие конфигурационные файлы>
	

	
FileSupplier

Интерфейс, имеющий все методы, необходимые для работы тестирующей системы:

boolean addProblemFolder(String problemFolder);
Path getProblemFolder(String problemFolder);
Path getProblemStatement(String problemFolder);
Path getProblemCheckerFolder(String problemFolder);

Path getTestInputFile(String problemFolder, TestGroupType type, int testNumber);
Path getTestAnswerFile(String problemFolder, TestGroupType type, int testNumber);

boolean addAuthorDecisionFolder(String problemFolder, String authorDecisionFolder);
Path getAuthorDecisionFolder(String problemFolder, String authorDecisionFolder);
Path getAuthorDecisionSourceFolder(String problemFolder, String authorDecisionFolder);
Path getAuthorDecisionSourceFile(String problemFolder, String authorDecisionFolder);
Path getAuthorDecisionCompileFolder(String submiproblemFolder, String authorDecisionFolderssionFolder);
Path getAuthorDecisionCompileFile(String submisproblemFolder, String authorDecisionFoldersionFolder);

boolean addSubmissionFolder(String submissionFolder);
Path getSubmissionFolder(String submissionFolder);
Path getSubmissionSourceFolder(String submissionFolder);
Path getSubmissionSourceFile(String submissionFolder);
Path getSubmissionCompileFolder(String submissionFolder);
Path getSubmissionCompileFile(String submissionFolder);

boolean addCompetitionFolder(String competitionFolder);
Path getCompetitionVisibleResults(String competitionFolder, boolean checkExisting);

Path getTempFile();
void deleteTempFile(Path path);
void deleteAllTempFiles();

Path getConfigurationFolder();



StandardFileSupplier

Класс, реализующий интерфейс FileSupplier. Имеет статическое поле типа FileSupplier, содержащее в себе объект типа StandardFileSupplier, используемый по умолчанию. Имеет статический метод getDefault(), возврающий этот объект по умолчанию. Реализует все методы интерфейса FileSupplier.

/*Если метод возвращает путь к папке, перед возвращением результата всегда проверяет, существует ли папка, и, если нет, создаёт её. Если метод возвращает путь к файлу, всегда проверяет, существует ли папка, содержащая файл, и если нет, создаёт её, а если не существует файл, возвращает null.*/

Все реализуемые методы вначале реализуют закрытый метод checkFileStructure(), который сначала проверяет, существует ли папка file_system, и создаёт её, если не существует, и то же самое делает для папок problems, submissions, competitions, temp, config.

Все add-методы вначале проверяют существует ли уже соответсвующая папка. Если существует, возвращают false (означает неудачу создания папки). Если не существует, создают её и соответсвующую ей внутреннюю структуру (например, для папки с задачей внутри создаются только папки tests, checker, author_decisions; то есть создаются только папки на уровень ниже, файлы не создаются).

Get-методы (за некоторыми исключениями, см. далее) перед возвращением пути проверяют, существует ли искомая папка или файл. Если не существует, делать запись об этом в лог и возвращает null (искомая папка при этом не создаётся); если существует, возвращает путь.

Исключения:
getCompetitionVisibleResults(String competitionFolder, boolean checkExisting) - если флаг checkExisting равен true, работает по общему правилу, если false - возвращает путь в любом случае, вне зависимости от того, существует файл или нет.
getTempFile() - создаёт в папке temp новый временный файл (всегда новый) и возвращает путь к нему.

Уточнения:
getSubmissionSourceFile() и getAuthorDecisionSourceFile() вначале просматривают папку с исходным кодом (в ней должен лежать только один файл). Если в папке есть файл, возвращается путь к нему, если нет, возвращается null (отличие в том, что имя файла заранее не известно).
getSubmissionCompileFile() и getAuthorDecisionCompileFile() вначале получают имя файла с исходным кодом (без расширения), затем просматривают папку со скомпилированным решением (в ней может быть много файлов) и ищут в ней файл, имя которого (без расширения) совпадает с именем файла с исходным кодом. Если такого файла нет, возвращается null, если есть, - путь к нему.

Методы deleteTempFile() и deleteAllTempFiles() удаляют, соответственно, один временный файл (вначале проверяя, существует ли он), либо все временные файлы в папке temp.



FileSystemLogging

Файл со статическим полем типа Logger для логгирования. В классе StandardFileSupplier во всех ситуациях, когда что-то пошло не так (например, папка или файл не найдены, возвращается null), всегда необходимо выводить информацию об этом в лог. Исходный код класса FileSystemLogging приведён ниже:

---------------------------
package com.netcracker.filesystem.logging;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

public class FileSystemLogging {

    public static final String loggerName = "file_system";
    public static final Logger logger = Logger.getLogger(loggerName);
    static {
        logger.setLevel(Level.ALL);
        try {
            FileHandler fileHandler = new FileHandler(loggerName + ".log");
            fileHandler.setLevel(Level.ALL);
            logger.addHandler(fileHandler);
        } catch (IOException exception) {
            logger.log(Level.FINE, "Cannot create FileHandler", exception);
        }
    }
    
}
--------------------------



Структура модуля имеет следующий вид:

- com
	- netcracker
		- filesystem
			- supplier
				FileSupplier.java
				StandardFileSupplier.java
			- logging
				FileSystemLogging.java